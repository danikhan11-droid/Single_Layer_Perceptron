# -*- coding: utf-8 -*-
"""Untitled47.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1daEqJjCBhcji8A7Am1orYf37_wpeNJvz
"""

# Import required libraries
import numpy as np                       # For numerical operations
import pandas as pd                      # For handling datasets
import matplotlib.pyplot as plt          # For plotting graphs
from sklearn.linear_model import Perceptron  # Perceptron model from sklearn
from mlxtend.plotting import plot_decision_regions  # To plot decision regions

# Load the dataset into a DataFrame
df = pd.read_csv('/content/placementdata.csv')  # Read CSV file from Google Colab

# Select the first two columns as input features
X = df.iloc[:, 0:2]                          # Take first two columns for 2D plotting

# Convert the 'PlacementStatus' column into a binary classification target
# 'Placed' is positive (1), 'NotPlaced' is negative (0)
y = (df['PlacementStatus'] == 'Placed').astype(int)

# Initialize two Perceptrons with different learning rates
p1 = Perceptron(max_iter=1000, eta0=0.1, random_state=42)  # Perceptron 1
p2 = Perceptron(max_iter=1000, eta0=0.5, random_state=42)  # Perceptron 2

# Train both models on the dataset
p1.fit(X, y)  # Train Perceptron 1
p2.fit(X, y)  # Train Perceptron 2

# Print the learned weights (coefficients) for both perceptrons
print("Perceptron 1 coefficients:", p1.coef_)  # Weights of p1
print("Perceptron 2 coefficients:", p2.coef_)  # Weights of p2

# Print the accuracy of both models on the training data
print("Perceptron 1 Accuracy:", p1.score(X, y))  # Accuracy of p1
print("Perceptron 2 Accuracy:", p2.score(X, y))  # Accuracy of p2

# Create a figure for plotting
plt.figure(figsize=(8,6))  # Set the figure size

# Plot decision regions for Perceptron 1
plot_decision_regions(X.values, y.values, clf=p1, legend=1)  # Decision regions for p1

# Set the plot title
plt.title("Decision Boundaries for Perceptron 1 and 2")

# Plot decision boundary for Perceptron 2 manually
w = p2.coef_[0]       # Extract weight vector (w1, w2) for p2
b = p2.intercept_[0]  # Extract bias for p2

# Define the x-range for the line
x_min, x_max = X.iloc[:,0].min()-1, X.iloc[:,0].max()+1
x_points = np.linspace(x_min, x_max, 100)  # 100 points along x-axis

# Calculate corresponding y-values for the decision boundary line
y_points = -(w[0]*x_points + b)/w[1]       # Line equation: w1*x1 + w2*x2 + b = 0

# Plot Perceptron 2's decision boundary in green
plt.plot(x_points, y_points, color='green', linewidth=2, label='Perceptron 2')

# Show the legend for both boundaries
plt.legend()

# Display the final plot
plt.show()